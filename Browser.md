# 浏览器原理

## 浏览器进程与线程

浏览器内有多个进程，多个进程之间互不影响，

主要的进程有：

* 浏览器进程 主要是负责界面显示，用户交互，子进程管理，同时提供存储等功能
* 渲染进程 html css 和 javascript代码是在渲染进程中  
* GPU进程 是为了实现3d css的效果
* 网络进程 页面网络资源的加载
* 插件进程

## 为什么很多站点第二次打开速度会很快？

### 缓存机制 

缓存机制的实现主要是依赖于响应头部的一些字段

浏览器的缓存主要是包含两块的数据： **DNS缓存** 和 **页面资源缓存** 

* **DNS缓存**

  ​	DNS缓存其实就是将IP地址和域名的对应关系缓存起来，从而使得第二次访问同一个域名时，能够快速找到对应的IP地址，提高浏览器的第二次访问速度

* **页面资源缓存**

  ​	页面资源缓存主要是针对于讲访问的页面资源保存下来，实现这一个过程是主要通过请求头和响应头。

  `Cache-control： max-age = <seconds>` 声明缓存有效的时长，也就是说在这个时间段内，访问该网址的资源的话，会直接从缓存中读取

  如果超过这个 `max-age`指定的时间，那么浏览器会向服务器发送一个请求，如果服务器返回的是一个304 Not-modified 那么表明所访问的资源并没有改变，因此可以继续使用缓存，但是服务器端在生成状态码为304响应的时候，必须同时生成一下会存在于对应的200相应中的首部：Cache-Control、Content-Location、Date、ETag、Expires 和 Vary

  If-None-Match 要与ETag结合起来使用， ETag是一个资源的特定版本标识符，可以用来比较和识别服务器上的资源是否已经发生了变化

### 登录状态缓存

  * 用户输入用户名和密码发送给服务器，服务器验证用户信息正确后，会生成一端表示用户身份的字符串，并把这个字符串写到响应头set-cookie字段，
  * 当浏览器接收到响应后，会解析所返回的响应的响应头，如果响应头有set-cookie字段，那么会把这个字段所对应的字符串存储到浏览器本地，也就是存储到浏览器的cookie中
  * 当用户再次发起请求时，浏览器会自动将cookie中存储的信息写进请求头中的cookie字段里，
  * 服务器接收到请求后，解析请求头，拿到请求头中cookie字段对应的字符串，并查找后台，判断该用户的登录状态，然后生成包含该用户信息的页面数据，并把生成的数据发送给浏览器。

## 从输入URl到页面展示经历的过程

主要涉及到三个进程

* 浏览器进程  浏览器进程主要是负责与用户的交互，子进程的管理
* 网络进程  网络进程主要负责发送网络请求，解析响应头域
* 渲染进程 渲染进程的主要作用是负责加载html，js文件，渲染页面

**具体的步骤如下**

**用户输入**

​	用户在地址栏输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容还是请求的url，	如果用户输入的是关键字，则浏览器会通过默认的搜索引擎来合成一个新的带搜索内容的url，

​	如果判断输入的是一个url，例如baidu.conm，那么浏览器的地址栏会根据规则，给这个url加上对应的协议，从而合成为一个完整的url，如https://baidu.com 

​	当用户输入查询关键字并回车后，浏览器将离开当前页面，开始发送请求，加载新的页面，但在离开当前页面之前，浏览器提供了一个执行beforeunload事件的机会，通过beforeunload事件，页面可以进行一些清除数据的操作，可以询问用户是否离开当前页面。

**URl请求过程**

  在浏览器完成url的合成之后，浏览器进程通过进程间通信（IPC）将合成好的url请求发给网络进程，网络进程接收到这个合成好的url后，就会发送一个真正的url请求。

 发送url请求的具体内容：

​	浏览器会先查找本地缓存，如果浏览器本地存储有对应url的缓存，那么就直接返回缓存的资源；如果本地缓存中没有对应的资源，那么就进行网络请求，网络请求的第一步就是dns域名解析去获取对应服务器的IP地址，如果url请求的使用的协议是https，那么还要建立TLS链接。

​	链接建立后，浏览器端会构建请求头，请求行等信息，并把和该域名相关的cookie等数据放入到请求头，服务器接收到请求信息后，会根据请求生成对应响应（包括响应头，响应体和响应行）,并将响应发送给网络进程。网络进程接收到服务端发送的请求后，就开始解析响应行，响应头的内容。根据响应头的内容，网络进程会对该响应有不同的解析，其中主要的两种解析是：

（1）重定向

浏览器的网络进程解析响应行和响应头，如果响应行的状态码是301或者302，表明浏览器需要重定向到其他url，此时浏览器的网络进程会从响应头的location字段拿到重定向的url，并根据拿到的重定向的url重新发起一个url请求

（2）响应的数据类型处理

浏览器通过响应头的Content-type来判断这个响应的所传递的数据类型是什么。浏览器会根据content-type的值来决定如何显示响应体的内容。

`Content-type: text/html` 表明响应体是一个html格式的内容

`Content-type: application/octet-stream` 表明返回的数据是字节流类型，浏览器会按照下载类型来处理

不同类型的响应体也会导致浏览器的行为发生不同， 如果响应头的Content-type的值被判断为下载类型，那么这个响应体会被交给浏览器的下载管理器，同时该url的请求也就结束了，而如果content-type的值被判断为是一个html文件，那么浏览器会继续进程后续的页面渲染流程。

**准备渲染过程**

默认情况下，浏览器会为每一个页面创建一个渲染流程，每一个新打开的页面都会配套一个渲染流程。但对于用一个站点的多个页面会直接运行在用一个渲染进程中。

**同一个站点**: 指的 协议 + 根域名 相同的  例如： http://www.baidu.com  和 http://www.baidu.com/test 这两个页面就是在同一个站点下，所以这两个页面应该是运行在同一个渲染进程下的。

Chrome的默认策略是，每个标签对应一个渲染进程。但**如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程**。官方把这个默认策略叫process-per-site-instance

渲染进程准备好后，还不能直接进行文档解析，页面的渲染，因为此时页面文件还在网络进程中的响应体中，并没有提交给渲染进程，所以下一步就是将网络进程中的响应体内的数据传递给对应的渲染进程，进行渲染

**提交文档过程**

首先，浏览器的浏览器进程在接收到网络进程解析的响应头消息后，便向渲染进程发起 “提交文档” 的命令或信息；

当渲染进程接收到网络进程发送过来的提交文档的信息后，会和网络进程建立一个数据传输的管道

通过这个管道，网络进程可以将响应体的数据发送给渲染进程，数据传输完成后，渲染进程会返回 “确认提交”的消息给浏览器进程

浏览器进程接收到渲染进程发回来的“确认提交”后，会更新浏览器界面的状态，并更新浏览器的web页面

**渲染阶段**

​	一旦文档完成从网络进程到渲染进程的数据传输，那么渲染进程便开始页面解析和子资源的加载，一旦页面渲染完成，渲染进程会向浏览器进程发送相应的消息，刘篮球进程在接受到消息后，会停止标签图标上的加载动画

## 浏览器渲染过程

渲染过程是一个很长很复杂的过程，因此将渲染过程分为几个不容的阶段，每一个阶段我们应该重点关注，这个阶段的输入是什么，以及这个阶段的输出是什么

1. 构建DOM树阶段
2. 计算DOM树种每一个dom节点的css
3. 根据DOM树和计算出的每一个节点的css生成布局树
4. 根据布局树生成图层树
5. 根据图层树 绘制相应的图层

渲染过程可以大致分为这5个过程，其中第5个过程后还有其他几个方面

### 构建DOM树

| 输入     | 处理过程         | 输出  |
| -------- | ---------------- | ----- |
| html文件 | 浏览器html解析器 | DOM树 |

渲染阶段的第一步 是通过浏览器内置的html解析器将html文件解析，构建为一个DOM树。

### 样式计算(Recalculate Style)

| 输入              | 处理过程                                           | 输出                |
| ----------------- | -------------------------------------------------- | ------------------- |
| 各种来源的css样式 | css文件->styleSheets  -> 属性值标准化 ->继承和层叠 | 每一个DOM节点的样式 |

css文件类型主要有三种类型：

1. 通过ink引入外部css文件
2. `<style></style>`标签内的文件
3. 元素标签的内联样式

浏览器先将这三种对应的css样式语句转化为浏览器能够理解的styleSheets类型的数据，

再将styleSheets中属性所对应的值转为对应的标准化值，也就是浏览器所能理解的属性值

```css
For example:
body {color: white} => body {color: rgb(0,0,0)}
body {font-size: 2em} => body {font-size: 2px}
```

之后再根据继承和层叠规则，计算每一个DOM节点从父类继承而来的属性，以及每一个DOM节点所层叠的属性，最终将计算出来的每一个节点的属性存储在每一个节点的computedstyle结构中

### 布局阶段

**构建布局树**

| 输入                   | 处理过程     | 输出   |
| ---------------------- | ------------ | ------ |
| DOM树，计算出的css属性 | 只取展示节点 | 布局树 |

根据构建的DOM树和计算出的每一个节点的css属性的值，我们可以构建一个布局树，布局树中的节点只包含要在页面上展示的节点，也就是想head节点等这些不会在页面上展示的节点是不会存在于布局树中的，布局树中的节点只包含页面展示出来的节点和每一个节点对应的属性值

**布局计算**

计算布局树上每一个节点在页面上的坐标位置，会将每一个节点的几何位置结果再写入到布局树中的每一个节点中去

### 分层

| 输入   | 处理过程                                                     | 输出   |
| ------ | ------------------------------------------------------------ | ------ |
| 布局树 | 将特殊的节点放到一个图层上，普通的节点放到父节点所在的那个图层上 | 图层树 |

根据布局树，渲染引擎会为特定的节点生成专用的图层，并生成一颗对应的图层树，普通的节点位于父节点所在的图层

**Q：**什么类型的节点需要生成一个图层？

**A:** 第一种是拥有层叠上下文属性的元素会被提升为单独的一层， 

```css
position：fixed
z-index: 2
filter: blue(5px)
opacity: 0.5
```

第二种 需要裁剪(clip)的地方也会被创建图层 

什么是裁剪？ 当文字部分区域的大小超过容器元素的大小，那么浏览器就会裁剪这个文字部分到一个图层上

### 图层绘制

| 输入   | 处理过程                                                     | 输出     |
| ------ | ------------------------------------------------------------ | -------- |
| 图层数 | 将一个个图层拆分成一个个小的绘制指令吗，再把这些指令放到一个列表中 | 绘制列表 |

有了图层树之后，渲染引擎会对图层树中的每一个图层进行绘制。

会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个绘制列表

#### 栅格化（raster）操作

| 输入     | 处理过程                                         | 输出 |
| -------- | ------------------------------------------------ | ---- |
| 绘制列表 | 会将绘图层分成一个个小的图块，将图块栅格话为位图 | 位图 |

绘制列表只是记录绘制的顺序和绘制指令，实际上绘制操作是由渲染引擎中的合成线程来完成的

主线程将绘制列表中记录的绘制指令交给合成线程去绘制

=》合成线程会将图层分成一个个图块，

​	  **Q:** 为什么将图层要分成一个个图块

​	  **A:** 因为用户所能看到的页面（也就是视口）可能只是图层很小的一部分，如果加载整个图层，那么会拖慢浏览器运行的速度，所以可以将图层分为一个个图块，只渲染视口和视口旁边的图块

将图层分成一个个图块后，合成线程会优先将视口附近的图块生成位图，实际生成位图的操作是由栅格话来执行的，栅栏话就是将图块转为位图。

栅格化过程通常会使用GPU来加速生成，使用GPU生成栅图的过程就被称为快速栅格化，或者GPU栅格化，生成的位图被保存在GPU内存中。GPU操作时在GPU进程中进行的

## 合成和显示

| 输入           | 处理过程                                                     |                                |
| -------------- | ------------------------------------------------------------ | ------------------------------ |
| 所有生成的位图 | 图块全部生成为位图之后，会发送命令给浏览器线程，浏览器线程会将生成的位图展示给用户 | 最终在页面上显示出来相应的界面 |

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

浏览器进程里面有一个叫viz的组件，用来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

到这里，经过这一系列的阶段，编写好的HTML、CSS、JavaScript等文件，经过浏览器就会显示出漂亮的页面了。

### 重排，重绘，合成·

**重排**

​	当我们改变一个dom元素的大小，因为浏览器要重新布局，所以计算css属性到最后绘制都需要重新跑一遍，因此开销较大

**重绘**

​	重绘就是改变一个元素的颜色之类的，因为没有改变元素的大小，所以不需要重新生成布局树和图层数，因此只需要进行css属性计算和 重新绘制的步骤，所以开销比重排要写

**合成**

​	更改一个既不要布局也不要绘制的属性，那么渲染引擎就可以跳过布局和绘制阶段，只执行合成阶段，又因为合成阶段是在合成线程上执行的，不会占用主线程，因此合成的效率是最高的

## js执行上下文

### let var声明的变量的区别

let 声明的变量是存在于词法环境中的，

var function声明的变量是存在于变量环境中的，

当查找一个变量时，先从词法环境的栈顶去查找对应的变量，如果词法环境中没有我们要查找的变量再去变量环境中查找是否有我们需要的变量

### var,function变量提升

var，function的变量提升 指的是如果一个变量是由var或function声明的，那么这些通过var和funcion声明的变量会被提升到顶部，如果是在全局声明的，那么会提升到全局文件的顶部，如果是在

一个函数中声明的，那么会被提升到函数的顶部，而不是全局的顶部，

var 声明的变量，只是将对这个变量的声明提升到顶部，而赋值还是在原来的地方进行赋值

函数 如果是直接定义，那么会被全部提升，如果是赋值式声明，那么和var声明的变量的处理类似，先提升到顶部申明，之后再将函数赋值给声明的函数变量

### 闭包

闭包的形成 内部函数引用外部函数的变量，导致外部函数的变量在外部函数执行完时，不能被释放，从而形成闭包

词法作用域就是根据代码的位置来决定的，是一种静态的作用域，作用域链取决于词法作用域，其实词法作用域的作用就是决定了函数调用时，在函数外部查找变量的顺序。而作用域链其实就是通过作用域查找变量的链条。 作用域链取决于词法作用域

词法作用域是静态的作用域，在编码时已经决定了，所以函数在查找外部变量时，会按照函数定义的位置去查找，而与函数调用的位置无关

**闭包定义**

**在JavaScript中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是foo，那么这些变量的集合就称为foo函数的闭包**。

## 栈空间和堆空间

### JS 原始类型 与 引用类型的存储

js运行时，内存空间主要分为三类： 代码空间， 栈空间， 堆空间

栈空间就是我们反复提到的调用栈，调用栈就是用来存储执行上下文的，执行上下文中又分为变量环境和词法环境。

js基本数据类型的值都是直接存储在执行上下文中，也就是栈空间中，

但是对于引用类型的数据，将其分配到堆空间中，栈空间只保存对该引用类型数据在堆空间的引用(也就是该引用类型对象在堆空间的内存地址)

**总结**   原始的数据类型是直接存储在栈空间中的执行上下文中的，而引用类型的数据是存储在堆空间的，栈空间只保存该引用类型数据在堆内存的地址，通过地址去获取堆内存中的引用类型数据

**提问** 为什么不讲所有的数据存储在栈中？

首相 明确 栈中存储的是运行时，js的执行上下文，如果将所有的数据都存储在栈中，那么栈中存储的上下文会很大，会影响切换上下文的效率，从而导致代码的运行效率较低，所以一般将原始数据类型放到栈中，而将引用类型的数据放到堆中，栈中只保存引用数据类型在堆中的存储地址

**提问** 之前说内部函数调用外部函数的变量时，会形成闭包，导致外部函数变量无法被释放，但是我们也知道外部函数执行完毕之后，栈中的执行上下文会被销毁，那么闭包的数据到底存储在哪里呢？

当js引擎检测到有闭包存在时，则会在堆空间中创建一个闭包对象 `closure` ，闭包对象存储在堆中，而栈中只是对堆中这个闭包对象的引用。而所返回的内部函数或对象会保存对堆内存中该闭包的引用

所以可以得到外部函数变量的值。

## 垃圾数据如何自动回收

### 栈内存的垃圾数据是如何回收的

栈中保存的是执行上下文，当一个函数执行完毕后，JS引擎会通过将ESP(Evented State Processor 记录当前上下文执行状态的指针)指针下移，从而使得这个函数的执行上下文失效，从而被垃圾回收机制回收，

### 堆内存的垃圾数据如何回收

回收堆中的垃圾内存需要用到JS的垃圾回收器，垃圾回收器会判断堆中的数据是否还被引用，如果栈中的执行上下文中没有对该对象的引用，那么就会回收该对象所占用的堆内存空间



V8引擎会把堆内存分为两个部分 一个是新生代，另一个是老生代

**新生代**中存放的是生存时间短的对象， **老生代**中存放的是生存时间长的对象

新生区空间的容量相比较于老生代空间的容量较小

新生区 是通过副垃圾回收器来进行垃圾回收操作的

新生区通过Scavenge算法来执行清理操作，Scavenge算法会将新生区化为两个部分 一个部分是对象区域，另一个部分是空闲区域，会先将对象写入对象区域，如果对象区域被写满了，那么就会执行垃圾回收操作，将对象区域内没有被引用的对象清除掉，并将对象区域内存留的对象复制到空闲区域，那么对象区域就变味空闲区域，而空闲区域就变为对象区域，这就保证了空间内存地址的连续性。

新生区中如果一个对象两次垃圾清理后，都没有被清理掉，那么就会被晋升，也就是将该对象从新生代区域写入老生代区域中

老生代中的对象主要是两部分，一部分是从新生代中晋升上来的对象，另一部分是对象本身很大所以直接写入老生代中。

老生区主要是使用标记-清除算法进行垃圾回收

标记阶段就是从栈中一组根元素开始，递归遍历这组根元素，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据

老生代垃圾处理 通常会花很长时间，导致主线程暂停很长时间，为了减少老生代垃圾处理所带来的影响，V8采用**增量标记**，也就是一个标记阶段只执行很小一部分的标记，这样就能将一个整段的标记操作分隔为几个小的部分，从而减少垃圾回收所带来的影响
