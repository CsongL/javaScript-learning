# 浏览器原理

## 浏览器进程与线程

浏览器内有多个进程，多个进程之间互不影响，

主要的进程有：

* 浏览器进程 主要是负责界面显示，用户交互，子进程管理，同时提供存储等功能
* 渲染进程 html css 和 javascript代码是在渲染进程中  
* GPU进程 是为了实现3d css的效果
* 网络进程 页面网络资源的加载
* 插件进程

## 为什么很多站点第二次打开速度会很快？

### 缓存机制 

缓存机制的实现主要是依赖于响应头部的一些字段

浏览器的缓存主要是包含两块的数据： **DNS缓存** 和 **页面资源缓存** 

* **DNS缓存**

  ​	DNS缓存其实就是将IP地址和域名的对应关系缓存起来，从而使得第二次访问同一个域名时，能够快速找到对应的IP地址，提高浏览器的第二次访问速度

* **页面资源缓存**

  ​	页面资源缓存主要是针对于讲访问的页面资源保存下来，实现这一个过程是主要通过请求头和响应头。

  `Cache-control： max-age = <seconds>` 声明缓存有效的时长，也就是说在这个时间段内，访问该网址的资源的话，会直接从缓存中读取

  如果超过这个 `max-age`指定的时间，那么浏览器会向服务器发送一个请求，如果服务器返回的是一个304 Not-modified 那么表明所访问的资源并没有改变，因此可以继续使用缓存，但是服务器端在生成状态码为304响应的时候，必须同时生成一下会存在于对应的200相应中的首部：Cache-Control、Content-Location、Date、ETag、Expires 和 Vary

  If-None-Match 要与ETag结合起来使用， ETag是一个资源的特定版本标识符，可以用来比较和识别服务器上的资源是否已经发生了变化

### 登录状态缓存

  * 用户输入用户名和密码发送给服务器，服务器验证用户信息正确后，会生成一端表示用户身份的字符串，并把这个字符串写到响应头set-cookie字段，
  * 当浏览器接收到响应后，会解析所返回的响应的响应头，如果响应头有set-cookie字段，那么会把这个字段所对应的字符串存储到浏览器本地，也就是存储到浏览器的cookie中
  * 当用户再次发起请求时，浏览器会自动将cookie中存储的信息写进请求头中的cookie字段里，
  * 服务器接收到请求后，解析请求头，拿到请求头中cookie字段对应的字符串，并查找后台，判断该用户的登录状态，然后生成包含该用户信息的页面数据，并把生成的数据发送给浏览器。

## 从输入URl到页面展示经历的过程

主要涉及到三个进程

* 浏览器进程  浏览器进程主要是负责与用户的交互，子进程的管理
* 网络进程  网络进程主要负责发送网络请求，解析响应头域
* 渲染进程 渲染进程的主要作用是负责加载html，js文件，渲染页面

**具体的步骤如下**

**用户输入**

​	用户在地址栏输入一个查询关键字时，地址栏会判断输入的关键字是搜索内容还是请求的url，	如果用户输入的是关键字，则浏览器会通过默认的搜索引擎来合成一个新的带搜索内容的url，

​	如果判断输入的是一个url，例如baidu.conm，那么浏览器的地址栏会根据规则，给这个url加上对应的协议，从而合成为一个完整的url，如https://baidu.com 

​	当用户输入查询关键字并回车后，浏览器将离开当前页面，开始发送请求，加载新的页面，但在离开当前页面之前，浏览器提供了一个执行beforeunload事件的机会，通过beforeunload事件，页面可以进行一些清除数据的操作，可以询问用户是否离开当前页面。

**URl请求过程**

  在浏览器完成url的合成之后，浏览器进程通过进程间通信（IPC）将合成好的url请求发给网络进程，网络进程接收到这个合成好的url后，就会发送一个真正的url请求。

 发送url请求的具体内容：

​	浏览器会先查找本地缓存，如果浏览器本地存储有对应url的缓存，那么就直接返回缓存的资源；如果本地缓存中没有对应的资源，那么就进行网络请求，网络请求的第一步就是dns域名解析去获取对应服务器的IP地址，如果url请求的使用的协议是https，那么还要建立TLS链接。

​	链接建立后，浏览器端会构建请求头，请求行等信息，并把和该域名相关的cookie等数据放入到请求头，服务器接收到请求信息后，会根据请求生成对应响应（包括响应头，响应体和响应行）,并将响应发送给网络进程。网络进程接收到服务端发送的请求后，就开始解析响应行，响应头的内容。根据响应头的内容，网络进程会对该响应有不同的解析，其中主要的两种解析是：

（1）重定向

浏览器的网络进程解析响应行和响应头，如果响应行的状态码是301或者302，表明浏览器需要重定向到其他url，此时浏览器的网络进程会从响应头的location字段拿到重定向的url，并根据拿到的重定向的url重新发起一个url请求

（2）响应的数据类型处理

浏览器通过响应头的Content-type来判断这个响应的所传递的数据类型是什么。浏览器会根据content-type的值来决定如何显示响应体的内容。

`Content-type: text/html` 表明响应体是一个html格式的内容

`Content-type: application/octet-stream` 表明返回的数据是字节流类型，浏览器会按照下载类型来处理

不同类型的响应体也会导致浏览器的行为发生不同， 如果响应头的Content-type的值被判断为下载类型，那么这个响应体会被交给浏览器的下载管理器，同时该url的请求也就结束了，而如果content-type的值被判断为是一个html文件，那么浏览器会继续进程后续的页面渲染流程。

**准备渲染过程**

默认情况下，浏览器会为每一个页面创建一个渲染进程，每一个新打开的页面都会配套一个渲染流程。但对于用一个站点的多个页面会直接运行在用一个渲染进程中。

**同一个站点**: 指的 协议 + 根域名 相同的  例如： http://www.baidu.com  和 http://www.baidu.com/test 这两个页面就是在同一个站点下，所以这两个页面应该是运行在同一个渲染进程下的。

Chrome的默认策略是，每个标签对应一个渲染进程。但**如果从一个页面打开了另一个新页面，而新页面和当前页面属于同一站点的话，那么新页面会复用父页面的渲染进程**。官方把这个默认策略叫process-per-site-instance

渲染进程准备好后，还不能直接进行文档解析，页面的渲染，因为此时页面文件还在网络进程中的响应体中，并没有提交给渲染进程，所以下一步就是将网络进程中的响应体内的数据传递给对应的渲染进程，进行渲染

**提交文档过程**

首先，浏览器的浏览器进程在接收到网络进程解析的响应头消息后，便向渲染进程发起 “提交文档” 的命令或信息；

当渲染进程接收到网络进程发送过来的提交文档的信息后，会和网络进程建立一个数据传输的管道

通过这个管道，网络进程可以将响应体的数据发送给渲染进程，数据传输完成后，渲染进程会返回 “确认提交”的消息给浏览器进程

浏览器进程接收到渲染进程发回来的“确认提交”后，会更新浏览器界面的状态，并更新浏览器的web页面

**渲染阶段**

​	一旦文档完成从网络进程到渲染进程的数据传输，那么渲染进程便开始页面解析和子资源的加载，一旦页面渲染完成，渲染进程会向浏览器进程发送相应的消息, 览器进程在接受到消息后，会停止标签图标上的加载动画

## 浏览器渲染过程

渲染过程是一个很长很复杂的过程，因此将渲染过程分为几个不同的阶段，每一个阶段我们应该重点关注，这个阶段的输入是什么，以及这个阶段的输出是什么

1. 构建DOM树阶段
2. 计算DOM树种每一个dom节点的css
3. 根据DOM树和计算出的每一个节点的css生成布局树
4. 根据布局树生成图层树
5. 根据图层树 绘制相应的图层

渲染过程可以大致分为这5个过程，其中第5个过程后还有其他几个方面

### 构建DOM树

| 输入     | 处理过程         | 输出  |
| -------- | ---------------- | ----- |
| html文件 | 浏览器html解析器 | DOM树 |

渲染阶段的第一步 是通过浏览器内置的html解析器将html文件解析，构建为一个DOM树。

### 样式计算(Recalculate Style)

| 输入              | 处理过程                                           | 输出                |
| ----------------- | -------------------------------------------------- | ------------------- |
| 各种来源的css样式 | css文件->styleSheets  -> 属性值标准化 ->继承和层叠 | 每一个DOM节点的样式 |

css文件类型主要有三种类型：

1. 通过ink引入外部css文件
2. `<style></style>`标签内的文件
3. 元素标签的内联样式

浏览器先将这三种对应的css样式语句转化为浏览器能够理解的styleSheets类型的数据，

再将styleSheets中属性所对应的值转为对应的标准化值，也就是浏览器所能理解的属性值

```css
For example:
body {color: white} => body {color: rgb(0,0,0)}
body {font-size: 2em} => body {font-size: 2px}
```

之后再根据继承和层叠规则，计算每一个DOM节点从父类继承而来的属性，以及每一个DOM节点所层叠的属性，最终将计算出来的每一个节点的属性存储在每一个节点的computedstyle结构中

### 布局阶段

**构建布局树**

| 输入                   | 处理过程     | 输出   |
| ---------------------- | ------------ | ------ |
| DOM树，计算出的css属性 | 只取展示节点 | 布局树 |

根据构建的DOM树和计算出的每一个节点的css属性的值，我们可以构建一个布局树，布局树中的节点只包含要在页面上展示的节点，也就是想head节点等这些不会在页面上展示的节点是不会存在于布局树中的，布局树中的节点只包含页面展示出来的节点和每一个节点对应的属性值

**布局计算**

计算布局树上每一个节点在页面上的坐标位置，会将每一个节点的几何位置结果再写入到布局树中的每一个节点中去

### 分层

| 输入   | 处理过程                                                     | 输出   |
| ------ | ------------------------------------------------------------ | ------ |
| 布局树 | 将特殊的节点放到一个图层上，普通的节点放到父节点所在的那个图层上 | 图层树 |

根据布局树，渲染引擎会为特定的节点生成专用的图层，并生成一颗对应的图层树，普通的节点位于父节点所在的图层

**Q：**什么类型的节点需要生成一个图层？

**A:** 第一种是拥有层叠上下文属性的元素会被提升为单独的一层， 

```css
position：fixed
z-index: 2
filter: blue(5px)
opacity: 0.5
```

第二种 需要裁剪(clip)的地方也会被创建图层 

什么是裁剪？ 当文字部分区域的大小超过容器元素的大小，那么浏览器就会裁剪这个文字部分到一个图层上

### 图层绘制

| 输入   | 处理过程                                                     | 输出     |
| ------ | ------------------------------------------------------------ | -------- |
| 图层数 | 将一个个图层拆分成一个个小的绘制指令吗，再把这些指令放到一个列表中 | 绘制列表 |

有了图层树之后，渲染引擎会对图层树中的每一个图层进行绘制。

会把一个图层的绘制拆分成很多小的绘制指令，然后再把这些指令按照顺序组成一个绘制列表

#### 栅格化（raster）操作

| 输入     | 处理过程                                         | 输出 |
| -------- | ------------------------------------------------ | ---- |
| 绘制列表 | 会将绘图层分成一个个小的图块，将图块栅格话为位图 | 位图 |

绘制列表只是记录绘制的顺序和绘制指令，实际上绘制操作是由渲染引擎中的合成线程来完成的

主线程将绘制列表中记录的绘制指令交给合成线程去绘制

=》合成线程会将图层分成一个个图块，

​	  **Q:** 为什么将图层要分成一个个图块

​	  **A:** 因为用户所能看到的页面（也就是视口）可能只是图层很小的一部分，如果加载整个图层，那么会拖慢浏览器运行的速度，所以可以将图层分为一个个图块，只渲染视口和视口旁边的图块

将图层分成一个个图块后，合成线程会优先将视口附近的图块生成位图，实际生成位图的操作是由栅格话来执行的，栅栏话就是将图块转为位图。

栅格化过程通常会使用GPU来加速生成，使用GPU生成栅图的过程就被称为快速栅格化，或者GPU栅格化，生成的位图被保存在GPU内存中。GPU操作时在GPU进程中进行的

## 合成和显示

| 输入           | 处理过程                                                     |                                |
| -------------- | ------------------------------------------------------------ | ------------------------------ |
| 所有生成的位图 | 图块全部生成为位图之后，会发送命令给浏览器线程，浏览器线程会将生成的位图展示给用户 | 最终在页面上显示出来相应的界面 |

一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。

浏览器进程里面有一个叫viz的组件，用来接收合成线程发过来的DrawQuad命令，然后根据DrawQuad命令，将其页面内容绘制到内存中，最后再将内存显示在屏幕上。

到这里，经过这一系列的阶段，编写好的HTML、CSS、JavaScript等文件，经过浏览器就会显示出漂亮的页面了。

### 重排，重绘，合成·

**重排**

​	当我们改变一个dom元素的大小，因为浏览器要重新布局，所以计算css属性到最后绘制都需要重新跑一遍，因此开销较大

**重绘**

​	重绘就是改变一个元素的颜色之类的，因为没有改变元素的大小，所以不需要重新生成布局树和图层数，因此只需要进行css属性计算和 重新绘制的步骤，所以开销比重排要写

**合成**

​	更改一个既不要布局也不要绘制的属性，那么渲染引擎就可以跳过布局和绘制阶段，只执行合成阶段，又因为合成阶段是在合成线程上执行的，不会占用主线程，因此合成的效率是最高的

## js执行上下文

### let var声明的变量的区别

let 声明的变量是存在于词法环境中的，

var function声明的变量是存在于变量环境中的，

当查找一个变量时，先从词法环境的栈顶去查找对应的变量，如果词法环境中没有我们要查找的变量再去变量环境中查找是否有我们需要的变量

### var,function变量提升

var，function的变量提升 指的是如果一个变量是由var或function声明的，那么这些通过var和funcion声明的变量会被提升到顶部，如果是在全局声明的，那么会提升到全局文件的顶部，如果是在

一个函数中声明的，那么会被提升到函数的顶部，而不是全局的顶部，

var 声明的变量，只是将对这个变量的声明提升到顶部，而赋值还是在原来的地方进行赋值

函数 如果是直接定义，那么会被全部提升，如果是赋值式声明，那么和var声明的变量的处理类似，先提升到顶部申明，之后再将函数赋值给声明的函数变量

### 闭包

闭包的形成 内部函数引用外部函数的变量，导致外部函数的变量在外部函数执行完时，不能被释放，从而形成闭包

词法作用域就是根据代码的位置来决定的，是一种静态的作用域，作用域链取决于词法作用域，其实词法作用域的作用就是决定了函数调用时，在函数外部查找变量的顺序。而作用域链其实就是通过作用域查找变量的链条。 作用域链取决于词法作用域

词法作用域是静态的作用域，在编码时已经决定了，所以函数在查找外部变量时，会按照函数定义的位置去查找，而与函数调用的位置无关

**闭包定义**

**在JavaScript中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是foo，那么这些变量的集合就称为foo函数的闭包**。

一个帮助理解的例子： 图书馆是一个函数，图书馆里面的书是一个变量，你在图书管理看书是图书馆返回的一个函数，因为看书这个书是图书馆里的，所以书就相于是一个闭包变量

```javascript
function libary() {
    const books = ['I Saw', 'Go Back']; // 闭包变量
    return function(index) {
        let book = index >= books.length ? 'There is no such book' : books[index];
	console.log(book);
    }
```

## 栈空间和堆空间

### JS 原始类型 与 引用类型的存储

js运行时，内存空间主要分为三类： 代码空间， 栈空间， 堆空间

栈空间就是我们反复提到的调用栈，调用栈就是用来存储执行上下文的，执行上下文中又分为变量环境和词法环境。

js基本数据类型的值都是直接存储在执行上下文中，也就是栈空间中，

但是对于引用类型的数据，将其分配到堆空间中，栈空间只保存对该引用类型数据在堆空间的引用(也就是该引用类型对象在堆空间的内存地址)

**总结**   原始的数据类型是直接存储在栈空间中的执行上下文中的，而引用类型的数据是存储在堆空间的，栈空间只保存该引用类型数据在堆内存的地址，通过地址去获取堆内存中的引用类型数据

**提问** 为什么不将所有的数据存储在栈中？

首相 明确 栈中存储的是运行时，js的执行上下文，如果将所有的数据都存储在栈中，那么栈中存储的上下文会很大，会影响切换上下文的效率，从而导致代码的运行效率较低，所以一般将原始数据类型放到栈中，而将引用类型的数据放到堆中，栈中只保存引用数据类型在堆中的存储地址

**提问** 之前说内部函数调用外部函数的变量时，会形成闭包，导致外部函数变量无法被释放，但是我们也知道外部函数执行完毕之后，栈中的执行上下文会被销毁，那么闭包的数据到底存储在哪里呢？

当js引擎检测到有闭包存在时，则会在堆空间中创建一个闭包对象 `closure` ，闭包对象存储在堆中，而栈中只是对堆中这个闭包对象的引用。而所返回的内部函数或对象会保存对堆内存中该闭包的引用

所以可以得到外部函数变量的值。

## 垃圾数据如何自动回收

### 栈内存的垃圾数据是如何回收的

栈中保存的是执行上下文，当一个函数执行完毕后，JS引擎会通过将ESP(Evented State Processor 记录当前上下文执行状态的指针)指针下移，从而使得这个函数的执行上下文失效，从而被垃圾回收机制回收，

### 堆内存的垃圾数据如何回收

回收堆中的垃圾内存需要用到JS的垃圾回收器，垃圾回收器会判断堆中的数据是否还被引用，如果栈中的执行上下文中没有对该对象的引用，那么就会回收该对象所占用的堆内存空间



V8引擎会把堆内存分为两个部分 一个是新生代，另一个是老生代

**新生代**中存放的是生存时间短的对象， **老生代**中存放的是生存时间长的对象

新生区空间的容量相比较于老生代空间的容量较小

新生区 是通过副垃圾回收器来进行垃圾回收操作的

新生区通过Scavenge算法来执行清理操作，Scavenge算法会将新生区化为两个部分 一个部分是对象区域，另一个部分是空闲区域，会先将对象写入对象区域，如果对象区域被写满了，那么就会执行垃圾回收操作，将对象区域内没有被引用的对象清除掉，并将对象区域内存留的对象复制到空闲区域，那么对象区域就变为空闲区域，而空闲区域就变为对象区域，这就保证了空间内存地址的连续性。

新生区中如果一个对象两次垃圾清理后，都没有被清理掉，那么就会被晋升，也就是将该对象从新生代区域写入老生代区域中

老生代中的对象主要是两部分，一部分是从新生代中晋升上来的对象，另一部分是对象本身很大所以直接写入老生代中。

老生区主要是使用标记-清除算法进行垃圾回收

标记阶段就是从栈中一组根元素开始，递归遍历这组根元素，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据

老生代垃圾处理 通常会花很长时间，导致主线程暂停很长时间，为了减少老生代垃圾处理所带来的影响，V8采用**增量标记**，也就是一个标记阶段只执行很小一部分的标记，这样就能将一个整段的标记操作分隔为几个小的部分，从而减少垃圾回收所带来的影响

## setTimeout是如何实现的

在浏览器中 除了任务队列(也被称为消息队列，这个队列里面存储的就是一个个宏任务)，还有一个延迟执行队列，这个延迟执行队列就保存有及时任务，

浏览器在执行响应的任务时，会先从任务队列中取出头部的任务（宏任务)去执行，执行完之后，在去遍历一下延迟执行队列，看队列中的哪一个及时任务已经到时间了，从而去执行这个计时任务的回调函数。执行完延迟执行队列中到期的计时任务后，再次循环这个整个过程。

伪码如下：

```c
// 延时任务结构
struct DelayTask {
    int64 id;
    CallBackFunction cbf;
    int start_time;
    int delay_time;
};

DelayTask delayTask;
delayTask.cbf = cbfFunction; // 设置延时任务的回调函数
delayTask.start_time = getCurrentTime();// 设置这个延时任务开始的时间
delayTask.delay_time = dealy; // 设置延迟的时间



// 主线程文件

void processDelayTask(TaskQueue delayed_incoming_queue) {
    // 从delayed_incoming_queue中取出已经到期的定时任务
    // 依次执行这个取出的任务
}

void processTask(Task task) {
	// 执行从任务队列中取出的宏任务
}


TaskQueue delayed_incoming_queue;  // 延期任务队列，里面存放的都是DelayTask结构的延时任务
TaskQueue task_queue; // 任务队列， 任务队列中存放的是一个个宏任务
bool keep_running = true;
void MainThread() {
    for(::) {
        // 执行宏任务
        Task task =  task_queue.pop();
        processTask(task);
        
        // 执行延迟队列中到期的任务
        processDelayTask(delayed_incoming_queue);
       
        // 如果设置了退出标志，那么就直接退出
        id(!keep_running) {
            break;
        }
    }
}
```

当我们调用setTimeout()方法时，会返回一个定时器ID， 我们可以通过clearTimeout()方法和定时器ID取消这个定时器， 每一个定时器的ID在全局都是唯一的。

我们知道存在一个 `delayed_incoming_queue`, 那么clearTimeout()的内部实现其实就是通过计时器id去delayed_incoming_queue中查找对应的计时器，将对应的计时器从delayed_incoming_queue中删除可以得到消除这个计时器的功能。

### setTimout存在的一些问题，

1. 回调函数的执行会比指定的值间隔更长的时间，原因在于：因为计时器的执行是在任务队列中宏任务执行之后，所以如果当前宏任务执行所需要的时间很长，那么计时器的回调函数实际执行的时间也就不是所指定的时间。 **原因就是任务队列中宏任务的执行在延迟任务队列中的任务执行之前 **
2. 多层嵌套的setTimeout,那么系统会设置对端时间间隔为4毫秒
3. 对于未激活的页面，setTimeout执行最小间隔1000毫秒
4. setTimeout设置的延时是有最大值的，这是因为chrome实现的时候，是用32bit来存储所设置的计时时间，所以所能设置的最长时间是2147483647毫秒(相当于24.8天)，如果超出这个值，那么定时时间就会被至为0
5. 注意setTimeout回到函数中使用this指针，应为setTimeout是被全局调用的，所以回调函数也就相当于是被this调用的，所以会存在一定的问题

## 宏任务和微任务

promise.then(callback)中的callback就是放到微任务队列中

宏任务的时间粒度比较大，执行的时间间隔是不能精确控制的。这是因为我们难以控制任务在消息队列中的位置，消息队列也就是任务队列会被插入很多系统级的任务。这些系统级的任务的插入 是我们所不能控制的，因此两个我们插入的宏任务执行的时间间隔是难确定的。

### 微任务

微任务就是一个需要异步执行的函数，执行时机是在主函数执行结束之后，宏任务执行结束之前。

说白了 对于一个js文件就是，当前同步代码执行完毕之后，才会去执行微任务，执行完微任务后，当前的这个宏任务（或者说就是js文件)就结束了，从而去执行延时任务队列中的任务和消息队列中的下一个任务。

v8引擎在创建全局执行上下文的同时，v8引擎也会在内部创建一个微任务队列。

每一个宏任务内都有一个微任务队列，

**产生微任务的两种方式**：

1. 使用MutationObserver监控某个DOM节点，当dom节点发生了变化，那么就会产生一个对应的微任务
2. 通过Promise对象，当调用Promise.resolve()和Promise.rejct()时会产生一个微任务。

**何时执行微任务**

  直观的来看就是在执行完js的同步代码后，再去查看当前宏任务中的微任务队列是否为空，如果不为空的话就去执行微任务队列中的微任务。

内部机制是在js引擎准备退出全局执行上下文并清空调用栈的时候，引擎会检查该执行上下文中的微任务队列。在执行微任务的过程中产生的微任务也会放入当前宏任务的微任务队列中去执行，而不会放到下一个宏任务的微任务队列中。

### 协程

协程是比线程更轻量级的存在。协程可以看成是跑在线程上的任务，一个线程上有多个协程。

一个进程有多个线程，一线程有多个协程。但是在这个线程上只能执行一个协程。如果从A协程启动B协程，那么我们就把A协程称为B协程的父协程

协程不是被操作系统内核所管理，而完全由程序控制。协程的切换不会像线程切换那样消耗资源

生成器就是协程之间不断的切换

## DOM树如何生成

DOM树是HTML文件被渲染引擎内部的HTML解析器解析而生成的。

HTML解析器并不是等html文件完整的加载完成之后再去解析，而是网络进程接收到了多少html文件，html解析器就解析多少。

网络进程接收到的文件都是字节流，html解析器接收到的网络进程传递过来的也都是字节流，如何将字节流转变为DOM树，就是html解析器所要做的工作

将html解析器变为DOM树的步骤：

1. html解析器通过分词器将字节流变为一个个Token，Token分为两类：Tag Token 和 文本Token。
2. 第2个阶段和第三个阶段是同步进行的，需要将Token解析为DOM节点，并将DOM节点添加到DOM树中

HTML解析器维护了一个Token栈结构， 该栈结构的主要作用用来计算节点之间的父子关系。节点的父节点其实就是此时Token栈的栈顶元素

startTag 通常会被先压入栈内，处于栈底。 当遇到startTag就会创建对应的DOM节点，并将该startToken放入到栈内

对于文本Token不会将其压入账内，而是直接生成一个文本节点

当遇到EndTag 那么会进行出栈操作，直到遇到对应的startTag。 根据出栈的内容构建相应的DOM节点

通过分词器产生的新Token这样不停地压栈和出栈从而构建一个完整的DOM节点

**HTML解析器开始工作时，会默认创建了一个根为document的空DOM结构**

### html文件中存在script标签

当html解析器遇到script标签时，会暂停DOM的解析过程，去执行JavaScript代码。

在渲染引擎在遇到了Js脚本时，不管该脚本是否操纵了CSSOM，都会执行CSS文件下载，解析操作，解析完css文件后，再去执行js脚本。

**js文件会阻塞DOM的解析， css文件会阻塞js的解析** 所以在分析性能的时候，要重点关注一下js文件和css样式表文件。

html文件解析时，当碰到js文件时，会停止html文件解析，开始js文件的解析，而在js文件解析之前会先去下载css文件，解析对应的css样式文件。

所以这个对于一个html文件来说， 就是解析html，遇到js停止解析html, 解析js，在解析js之前，先下载css解析css。

## 显示器是怎么显示图像

刷新频率的含义： 60Hz的意思就是 每秒更新60张图片，更新的图片都来自于显卡中一个叫前缓冲区的地方。也就是说显示器每秒种会固定读取60次前缓冲区中的图像，并将这个图像显示到显示器上。

显卡的职责就是合成新的图像，并将图像保存到后缓冲区中，一旦显卡把合成的图像写到后缓冲区，系统就会让后缓冲区和前缓冲区互换，这样就能保证显示器能够读取到显卡最新合成的图像。

把渲染流水线每秒更新多少帧称为帧率，也就是每秒更新了多少张合成的图像，

## 分层和合成渲染机制

Chrome浏览器中的合成技术，可以用三个词来概括总结：**分层**， **分块**， **合成**

分层就是 将页面看成是由多个图片组合而成，而这些图片其实就是一个个图层。而将这些图层一个个合成，最终形成一个页面，这个就是合成的过程，

将页面分层处理之后，有时候改变的只是一个图层上的内容，因此就可以只重新绘制这个图层上的内容，而不需要重新绘制整个页面，节省了时间。

合成操作是在一个单独的合成线程上进行的，因此合成不会影响到主线程

**分块**

分块就是将图层分为一个个图块，优先渲染合成视口附近的图块。

Chrome采取了一个策略去减少用户看到页面的时间：**在首次合成图块的时候使用一个低分辨率的图片**。当页面正常比列的图片合成好后，再用这个正常的图片去替代这个低分辨率的图片

## 如何系统地优化？

一个页面主要有三个阶段： 加载阶段，交互阶段，关闭阶段

1. 加载阶段：发送请求到渲染出完整页面的过程，主要限制在于网络速度和JavaScript脚本
2. 交互阶段：页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是JavaScript脚本
3. 关闭阶段： 用户发出关闭页面指令后的一些操作

### 加载阶段

加载阶段最主要的优化就是优化 **主要资源的数量和大小**。 主要资源就是指会阻塞页面渲染的资源。例如js文件，css文件。

主要的优化手段有：

1. 优化主要资源的数量
2. 优化主要资源的大小
3. 优化请求主要资源的时间，减少RTT时间。 RRT是指 服务器开始发送某一资源到服务器完成这一资源发送所需要的时间。

在加载阶段总的优化原则是：**减少关键资源的个数，降低关键资源的大小，降低关键资源的RTT次数**

### 交互阶段

谈论交互阶段的优化就是讨论渲染进程渲染帧的速度。所以优化的方向就是让单个帧的生成速度变快。

在交互阶段优化方案：

1. 减少javaScript脚本执行时间。   一种是将函数拆分，另一种是将与dom操作无关的js交给web workers线程去做，webworkers线程不会阻塞主线程，但是webworkers不能操作dom节点，所以应该将与dom操作无关的js脚本交给webworkers去做
2. 避免强制同步结局  强制同步布局是指，通常js脚本改变样式之后，会在另一个任务中进行样式和布局的重新计算，但若是前置其在同一个任务中进行，那么就会导致任务被堵赛
3. 避免布局抖动。 布局抖动就是指 在一次javascript执行的过程中，多次执行强制布局和抖动操作。
4. 合理利用css动画。合成动画是在合成线程上做的，能够利用css去生成动画就用css去做。如果能够提前知道对某个元素执行动画操作，那么最好将其标记为will-change。
5. 避免频繁的垃圾回收

## 虚拟DOM

如果直接修改对DOM进行修改，那么代价是很大的，例如如果我们修改很小的一个地方时，就直接对真实DOM修改，那么就需要重新渲染整个页面，如果页面内容很复杂，那么渲染整个页面所带来的代价是十分大的，因此 虚拟dom就是用来解决这个问题

虚拟dom是如何解决的呢？ 每次更改时，我们都会产生一个虚拟dom去展示这次更改，之后我们再用更改后新生成的虚拟dom与更改之前的虚拟dom进行比较，如果新的虚拟dom的变化达到一定的程度，那么这个时候才会去一次性更新真是dom。

虚拟dom其实就相当于是真实dom的缓冲区，不是对于每一次修改都将其直接反应到dom上，而是先将修改写入到新的虚拟dom上，当达对虚拟dom修改达到一定程度后再去修改真是dom，从而真是dom更新的频率，提高效率。

