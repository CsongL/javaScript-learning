## HTTP 1.0 and HTTP 2.0

### HTTP 1.0
HTTP1.0 被称为是无状态无连接应用层协议
**无状态**是指 不会保存连接的状态即不会保存该链接的用户信息等
**无链接**是指 每次发送一个请求都需要建立不同的TCP连接，消耗资源和时间，
**队头堵塞问题** 下一个请求必须等到上一个请求的响应返回后才能发送，因此会导致队头的请求很长时间完不成，后面的请求也没办法发送


### HTTP1.1
针对HTTP1.0协议的问题做出改进
针对无链接 改进为 **长链接** 增加了一个Connection字段，通过设置Keep-alive保证链接不断开
支持请求管道化 在长连接的基础上使得请求“并行”成为可能
但这种并行其实 就是同一个域下建立多个与服务器连接的TCP连接，然后在这多个TCP连接中发送不同的请求从而实现了"并行"， 这也就是为什么浏览器限制同域下只能进行6-8个资源加载

HTTP1.1还是没能在根本上解决 队头阻塞的问题 还是在同一个连接中，必须前面的请求接收到响应后才能发送下一个请求，但通过多个建立多个TCP连接也可以在一定程度上缓解





### HTTP 2.0
#### 二进制数据帧
HTTP1.x 是通过文本的形式来传递数据，而HTTP2.0是通过二进制流来传递数据
帧是HTTP2.0传输数据消息的最小单位
#### HTTP2.0 多路复用  
同域名下的所有通信都在单个连接中完成
因为HTTP2.0是通过二进制数据流来传递的, 所以可以在单个链接中存在任意数量的二进制双向数据流
数据流以消息的形式发送，消息又是有一个个帧组成，帧可以乱序发送，因为可以通过帧前面的流标识来进行重新组装
每个请求可以带一个31bit的优先值，数值越大优先级越低，对于不同的优先级的请求客户端和服务器在进行处理时，可以采取不同的策略


HTTP2.0实现了真正意义上的并行传输，可以在一个TCP连接中进行任意数量的HTTP请求, 
这主要就是因为采用二进制分帧来传输数据，从而实现了真正的并行

### 服务器推送
HTTP2.0下 服务器可以主动的向客户端推送资源，而不同等到客户端发送来请求在做出响应
如果服务器端推送的资源已经在客户端缓存过了，那么浏览器可以通过RST_STREAM帧来拒收
当然主动推送也要遵守同源策略

### 头部压缩
HTTP1.x 中请求或响应的头部都是通过纯文本传输的，负荷会比较大
HTTP2.0 是encoder来减少需要传输的header大小。客户端与服务器会各自保存一份header fileds表，避免重复header的传输，也减小了传输大小


## HTTP1.x keep-alive  与 HTTP2.0 多路复用 对比
* HTTP1.x keep-alive 传输的是文本只能将文本整体的传输; HTTP2.0 传输的二进制数据流，可以将数据流分为多个不同的帧
* HTTP1.x keep-alive 通过创建多个TCP连接来缓解队头阻塞问题; HTTP2.0同域名下所有的通信都可以在一个单链接中完成，一个单链接中可以有任意个数据流双向传输
* HTTP1.x keep-alive 必须按照请求的顺序返回对应的响应; HTTP2.0 多路复用可以不按照顺序返回，因为可以通过帧上的流标识重组
* HTTP/1.x keep-alive 单个 TCP 连接在同一时刻只能处理一个请求（两个请求的生命周期不能重叠）；HTTP/2 单个 TCP 同一时刻可以发送多个请求和响应


## HTTP3.0
HTTP3.0是基于UDP建立的，UDP是传输层协议，在HTTP3.0中, 在HTTP和UDP中间还有一个QUIC协议(Quick UDP Internect Connection),QUIC是基于UDP的一种协议，而HTTP3.0又是基于QUIC的
QUIC基于UDP对HTTP2.0中的优点进行了实现，并且也解决了一些HTTP2.0中的问题
  1. QUIC基于UDP, 因此不需要繁琐的TCP握手连接，因此提高了响应速度
  2. QUIC也降低了队头阻塞问题带来的影响，在HTTP2.0如果一个流有一个包丢失，那么在重传前后的stream都会收到影响，而对于QUICK,因为是基于UDP，所以丢包只会影响到丢包的流，而不会影响到其他流
  3. QUIC的首次连接和非首次连接，首次连接需要交换进行客户端和服务器端秘钥的交换，从而实现加密传输，并且将交换的秘钥配置分别存储在客户端和服务器端，因此在下次连接时，可以直接使用秘钥进行加密传输
  4. QUIC可以进行精确的流量控制，QUIC协议可以控制每一个流所占用的最大的buffer size， 从而进行精确的流控制
  5. QUIC优化了连接迁移 TCP连接基于四元组（源IP、源端口、目的IP、目的端口)，切换网络时至少会有一个因素发生变化，导致连接发生变化。当连接发生变化时，如果还使用原来的TCP连接，则会导致连接失败，就得等原来的连接超时后重新建立连接，所以我们有时候发现切换到一个新网络时，即使新网络状况良好，但内容还是需要加载很久。如果实现得好，当检测到网络变化时立刻建立新的TCP连接，即使这样，建立新的连接还是需要几百毫秒的时间。QUIC的连接不受四元组的影响，当这四个元素发生变化时，原连接依然维持。QUIC连接不以四元组作为标识，而是使用一个64位的随机数，这个随机数被称为Connection lD，对应每个stream，即使IP或者端口发生变化，只要Connection ID没有变化，那么连接依然可以维持。


QUIC实现的核心观念是：基于UDP主体将TCP的重要功能转移到用户空间来实现，从而逃开了内核，实现了用户态的TCP协议

## Reference
https://juejin.cn/post/6963931777962344455#heading-1
[HTTP3.0](https://blog.51cto.com/u_15295488/3129473)