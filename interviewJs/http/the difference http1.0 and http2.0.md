## HTTP 1.0 and HTTP 2.0

### HTTP 1.0
HTTP1.0 被称为是无状态无连接应用层协议
**无状态**是指 不会保存连接的状态即不会保存该链接的用户信息等
**无链接**是指 每次发送一个请求都需要建立不同的TCP连接，消耗资源和时间，
**队头堵塞问题** 下一个请求必须等到上一个请求的响应返回后才能发送，因此会导致队头的请求很长时间完不成，后面的请求也没办法发送


### HTTP1.1
针对HTTP1.0协议的问题做出改进
针对无链接 改进为 **长链接** 增加了一个Connection字段，通过设置Keep-alive保证链接不断开
支持请求管道化 在长连接的基础上使得请求“并行”成为可能
但这种并行其实 就是同一个域下建立多个与服务器连接的TCP连接，然后在这多个TCP连接中发送不同的请求从而实现了"并行"， 这也就是为什么浏览器限制同域下只能进行6-8个资源加载

HTTP1.1还是没能在根本上解决 队头阻塞的问题 还是在同一个连接中，必须前面的请求接收到响应后才能发送下一个请求，但通过多个建立多个TCP连接也可以在一定程度上缓解





### HTTP 2.0
#### 二进制数据帧
HTTP1.x 是通过文本的形式来传递数据，而HTTP2.0是通过二进制流来传递数据
帧是HTTP2.0传输数据消息的最小单位
#### HTTP2.0 多路复用  
同域名下的所有通信都在单个连接中完成
因为HTTP2.0是通过二进制数据流来传递的, 所以可以在单个链接中存在任意数量的二进制双向数据流
数据流以消息的形式发送，消息又是有一个个帧组成，帧可以乱序发送，因为可以通过帧前面的流标识来进行重新组装
每个请求可以带一个31bit的优先值，数值越大优先级越低，对于不同的优先级的请求客户端和服务器在进行处理时，可以采取不同的策略


HTTP2.0实现了真正意义上的并行传输，可以在一个TCP连接中进行任意数量的HTTP请求, 
这主要就是因为采用二进制分帧来传输数据，从而实现了真正的并行

### 服务器推送
HTTP2.0下 服务器可以主动的向客户端推送资源，而不同等到客户端发送来请求在做出响应
如果服务器端推送的资源已经在客户端缓存过了，那么浏览器可以通过RST_STREAM帧来拒收
当然主动推送也要遵守同源策略

### 头部压缩
HTTP1.x 中请求或响应的头部都是通过纯文本传输的，负荷会比较大
HTTP2.0 是encoder来减少需要传输的header大小。客户端与服务器会各自保存一份header fileds表，避免重复header的传输，也减小了传输大小


## HTTP1.x keep-alive  与 HTTP2.0 多路复用 对比
* HTTP1.x keep-alive 传输的是文本只能将文本整体的传输; HTTP2.0 传输的二进制数据流，可以将数据流分为多个不同的帧
* HTTP1.x keep-alic  e 通过创建多个TCP连接来缓解队头阻塞问题; HTTP2.0同域名下所有的通信都可以在一个单链接中完成，一个单链接中可以有任意个数据流双向传输
* HTTP1.x keep-alive 必须按照请求的顺序返回对应的响应; HTTP2.0 多路复用可以不按照顺序返回，因为可以通过帧上的流标识重组
* HTTP/1.x keep-alive 单个 TCP 连接在同一时刻只能处理一个请求（两个请求的生命周期不能重叠）；HTTP/2 单个 TCP 同一时刻可以发送多个请求和响应


## Reference
https://juejin.cn/post/6963931777962344455#heading-1