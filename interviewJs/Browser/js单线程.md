## Js单线程
浏览器中多个进程主要有：
1. 浏览器进程
2. 网络进程
3. GPU进程
4. 插件进程
5. 渲染进程

默认情况一下 每一个页面都会新创建一个渲染进程，但多个页面如果是属于同一个站点，那么这多个页面会共享同一个渲染进程

渲染进程主要的任务就是 页面渲染，js脚本执行，事件处理等， 对于前端来说渲染进程是最重要的

### 为什么js是单线程
Javascript是一门脚本语言，主要的作用就是用户交互以及操作dom, 如果js是多线程的，那么如果我们两个js线程同时对同一个dom操作，那么这个dom最后的结果就不确定，如果想要实现js的多线程，那么还要设计如何实现同步，如何加锁，所以为了避免复杂化，就保持了js单线程的特性

#### webwoker
创建Worker时，JS引擎向浏览器申请开一个子线程（子线程是浏览器开的，完全受主线程控制，而且不能操作DOM）
JS引擎线程与worker线程间通过特定的方式通信（postMessage API，需要通过序列化对象来与线程交互特定的数据）



### 渲染进程
渲染进程中主要的线程有
1. GUI渲染线程 主要负责浏览器页面的渲染，html, csss解析，dom树和render树的渲染
2. Js引擎线程 主要是负责解析js脚本，运行js脚本(也就是该线程内使用V8引擎)
3. 事件触发线程，归属于浏览器而不是js引擎，用来控制事件循环
4. 定时触发线程 用来处理setTimeout 与 setInterval

其中比较重要的是:
### GUI渲染线程 和 Js引擎线程会相互阻塞
为什么会相互阻塞？ 
js代码可以修改dom元素， 如果我们在渲染dom元素的同时，js代码去修改这个dom元素上的数据，那么渲染后的dom元素的数据可能会与我们想要的不一致



### CSS的下载与解析
css的下载不会阻塞dom树的构建，因为css是由单独的下载线程异步下载的，因此dom树可以正常构建
但css会阻塞render(渲染)树的构建，因为渲染数的构建需要css的信息

### Reference
[浏览器](https://segmentfault.com/a/1190000012925872)